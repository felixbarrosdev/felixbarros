const { test, expect } = require('@playwright/test');

test.describe('Formulario de Comentarios', () => {
  test.beforeEach(async ({ page }) => {
    // Ir directamente a una p√°gina espec√≠fica con comentarios
    await page.goto('/?p=109');
    await page.waitForLoadState('networkidle');
    
    // Esperar un poco m√°s para asegurar que todo se cargue
    await page.waitForTimeout(2000);
    
    // Scroll hacia abajo donde deber√≠a estar el formulario
    await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
    await page.waitForTimeout(1000);
  });

  test('deber√≠a mostrar el formulario de comentarios', async ({ page }) => {
    // Esperar a que el formulario aparezca con timeout m√°s largo
    const commentForm = page.locator('#respond, #commentform, .comment-form, form[action*="comment"], .comment-form-wrapper');
    
    // Intentar m√∫ltiples selectores
    await expect(commentForm.first()).toBeVisible({ timeout: 15000 });
    
    console.log('‚úÖ Formulario de comentarios visible');
  });

  test('deber√≠a tener todos los campos necesarios', async ({ page }) => {
    // Verificar textarea para el comentario
    const commentTextarea = page.locator('textarea[name="comment"], #comment');
    await expect(commentTextarea).toBeVisible();
    await expect(commentTextarea).toHaveAttribute('required');
    
    // Verificar campo nombre
    const authorField = page.locator('input[name="author"], #author');
    await expect(authorField).toBeVisible();
    
    // Verificar campo email
    const emailField = page.locator('input[name="email"], #email');
    await expect(emailField).toBeVisible();
    
    // Verificar bot√≥n de env√≠o
    const submitButton = page.locator('input[type="submit"], button[type="submit"]');
    await expect(submitButton).toBeVisible();
    
    console.log('‚úÖ Todos los campos del formulario est√°n presentes');
  });

  test('deber√≠a tener placeholders apropiados', async ({ page }) => {
    const commentTextarea = page.locator('textarea[name="comment"]');
    const placeholder = await commentTextarea.getAttribute('placeholder');
    expect(placeholder).toBeTruthy();
    expect(placeholder.length).toBeGreaterThan(5);
    
    const authorField = page.locator('input[name="author"]');
    const authorPlaceholder = await authorField.getAttribute('placeholder');
    expect(authorPlaceholder).toBeTruthy();
    
    console.log(`‚úÖ Placeholders: "${placeholder}", "${authorPlaceholder}"`);
  });

  test('deber√≠a permitir escribir en todos los campos', async ({ page }) => {
    // Escribir en el textarea del comentario
    const commentText = 'Este es un comentario de prueba para verificar funcionalidad';
    await page.fill('textarea[name="comment"]', commentText);
    await expect(page.locator('textarea[name="comment"]')).toHaveValue(commentText);
    
    // Escribir nombre del autor
    const authorName = 'Usuario de Prueba';
    await page.fill('input[name="author"]', authorName);
    await expect(page.locator('input[name="author"]')).toHaveValue(authorName);
    
    // Escribir email
    const email = 'test@ejemplo.com';
    await page.fill('input[name="email"]', email);
    await expect(page.locator('input[name="email"]')).toHaveValue(email);
    
    // Escribir URL si existe
    const urlField = page.locator('input[name="url"]');
    if (await urlField.count() > 0) {
      const website = 'https://ejemplo.com';
      await page.fill('input[name="url"]', website);
      await expect(urlField).toHaveValue(website);
    }
    
    console.log('‚úÖ Todos los campos permiten escribir correctamente');
  });

  test('deber√≠a validar campos requeridos', async ({ page }) => {
    // Intentar enviar formulario sin llenar campos requeridos
    const submitButton = page.locator('input[type="submit"], button[type="submit"]');
    
    // Verificar que el comentario es requerido
    await submitButton.click();
    
    // En navegadores modernos, deber√≠a aparecer mensaje de validaci√≥n
    const commentField = page.locator('textarea[name="comment"]');
    const validationMessage = await commentField.evaluate(el => el.validationMessage);
    
    if (validationMessage) {
      expect(validationMessage.length).toBeGreaterThan(0);
      console.log(`‚úÖ Validaci√≥n funcionando: "${validationMessage}"`);
    } else {
      console.log('‚ÑπÔ∏è Validaci√≥n HTML5 no detectada o personalizada');
    }
  });

  test('deber√≠a tener estilos apropiados en desktop', async ({ page }) => {
    await page.setViewportSize({ width: 1200, height: 800 });
    
    const commentForm = page.locator('#respond, #commentform, .comment-form, form[action*="comment"], .comment-form-wrapper');
    await expect(commentForm.first()).toBeVisible({ timeout: 15000 });
    const formBox = await commentForm.first().boundingBox();
    
    // Verificar que el formulario no es muy ancho
    expect(formBox.width).toBeLessThanOrEqual(800);
    expect(formBox.width).toBeGreaterThan(300);
    
    // Verificar campos individuales
    const textarea = page.locator('textarea[name="comment"]');
    const textareaBox = await textarea.boundingBox();
    
    expect(textareaBox.height).toBeGreaterThan(100); // Altura m√≠nima
    expect(textareaBox.width).toBeGreaterThan(200);
    
    console.log(`‚úÖ Desktop: Formulario ${formBox.width}px, textarea ${textareaBox.width}x${textareaBox.height}px`);
  });

  test('deber√≠a ser responsive en m√≥vil', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.waitForTimeout(1000);
    
    const commentForm = page.locator('#respond, #commentform, .comment-form, form[action*="comment"], .comment-form-wrapper');
    await expect(commentForm.first()).toBeVisible({ timeout: 15000 });
    
    // Verificar que no hay scroll horizontal
    const bodyScrollWidth = await page.evaluate(() => document.body.scrollWidth);
    const windowWidth = await page.evaluate(() => window.innerWidth);
    expect(bodyScrollWidth).toBeLessThanOrEqual(windowWidth + 10);
    
    // Verificar campos en m√≥vil
    const inputs = await page.locator('input[type="text"], input[type="email"], textarea').all();
    
    for (const input of inputs) {
      if (await input.isVisible()) {
        const box = await input.boundingBox();
        expect(box.height).toBeGreaterThan(35); // Altura m√≠nima para touch
        expect(box.width).toBeLessThanOrEqual(375); // No m√°s ancho que la pantalla
      }
    }
    
    console.log('‚úÖ M√≥vil: Formulario responsive, campos apropiados para touch');
  });

  test('deber√≠a tener contraste adecuado', async ({ page }) => {
    const styleIssues = await page.evaluate(() => {
      const inputs = Array.from(document.querySelectorAll('input[type="text"], input[type="email"], textarea'));
      const issues = [];
      
      inputs.forEach(input => {
        const styles = window.getComputedStyle(input);
        const color = styles.color;
        const backgroundColor = styles.backgroundColor;
        const border = styles.border;
        
        // Verificar que hay contraste
        if (color === backgroundColor) {
          issues.push(`${input.name}: mismo color de texto y fondo`);
        }
        
        // Verificar que hay border visible
        if (border === 'none' || styles.borderWidth === '0px') {
          issues.push(`${input.name}: sin border visible`);
        }
        
        // Verificar que no es muy peque√±o
        const rect = input.getBoundingClientRect();
        if (rect.height < 35) {
          issues.push(`${input.name}: muy peque√±o (${rect.height}px)`);
        }
      });
      
      return issues;
    });
    
    console.log('üîç Problemas de estilo detectados:', styleIssues);
    
    // Permitir algunos problemas menores, pero no cr√≠ticos
    const criticalIssues = styleIssues.filter(issue => 
      issue.includes('mismo color') || issue.includes('muy peque√±o')
    );
    
    expect(criticalIssues.length).toBeLessThan(2);
  });

  test('deber√≠a enfocar campos correctamente con teclado', async ({ page }) => {
    // Probar navegaci√≥n por teclado
    await page.keyboard.press('Tab');
    
    // Verificar que podemos enfocar el textarea
    const commentField = page.locator('textarea[name="comment"]');
    await commentField.focus();
    await expect(commentField).toBeFocused();
    
    // Navegar al siguiente campo
    await page.keyboard.press('Tab');
    const authorField = page.locator('input[name="author"]');
    await expect(authorField).toBeFocused();
    
    // Navegar al campo email
    await page.keyboard.press('Tab');
    const emailField = page.locator('input[name="email"]');
    await expect(emailField).toBeFocused();
    
    console.log('‚úÖ Navegaci√≥n por teclado funcional');
  });

  test('deber√≠a mostrar indicadores visuales de foco', async ({ page }) => {
    const commentField = page.locator('textarea[name="comment"]');
    await commentField.focus();
    
    // Verificar que hay indicador visual de foco
    const focusStyles = await commentField.evaluate(el => {
      const styles = window.getComputedStyle(el);
      return {
        outline: styles.outline,
        outlineWidth: styles.outlineWidth,
        boxShadow: styles.boxShadow,
        borderColor: styles.borderColor
      };
    });
    
    const hasFocusIndicator = 
      focusStyles.outline !== 'none' ||
      focusStyles.outlineWidth !== '0px' ||
      focusStyles.boxShadow !== 'none' ||
      focusStyles.borderColor.includes('rgb');
    
    expect(hasFocusIndicator).toBeTruthy();
    console.log('‚úÖ Indicadores de foco presentes:', focusStyles);
  });

  test('deber√≠a funcionar el env√≠o del formulario (sin enviarlo realmente)', async ({ page }) => {
    // Llenar el formulario completo
    await page.fill('textarea[name="comment"]', 'Comentario de prueba automatizada');
    await page.fill('input[name="author"]', 'Test User');
    await page.fill('input[name="email"]', 'test@test.com');
    
    const urlField = page.locator('input[name="url"]');
    if (await urlField.count() > 0) {
      await page.fill('input[name="url"]', 'https://test.com');
    }
    
    // Interceptar el env√≠o para no enviarlo realmente
    await page.route('**/*wp-comments-post.php*', route => {
      console.log('üö´ Interceptado env√≠o del formulario (test)');
      route.fulfill({
        status: 200,
        body: 'Test intercepted'
      });
    });
    
    const submitButton = page.locator('input[type="submit"], button[type="submit"]');
    await submitButton.click();
    
    console.log('‚úÖ Formulario se puede enviar (interceptado para test)');
  });

  test('deber√≠a mostrar la secci√≥n de comentarios existentes si los hay', async ({ page }) => {
    // Buscar secci√≥n de comentarios existentes
    const commentsSection = page.locator('.comments-area, #comments, .comment-list, ol.commentlist, .wp-block-comments');
    const commentItems = page.locator('.comment, .comment-body, li[id*="comment-"], article[id*="comment-"]');
    
    const commentsCount = await commentItems.count();
    
    if (commentsCount > 0) {
      await expect(commentsSection).toBeVisible();
      console.log(`‚úÖ Se encontraron ${commentsCount} comentarios listados`);
      
      // Verificar estructura de comentarios
      const firstComment = commentItems.first();
      await expect(firstComment).toBeVisible();
      
      // Buscar elementos t√≠picos de un comentario
      const commentContent = firstComment.locator('.comment-content, .comment-text, p');
      const commentAuthor = firstComment.locator('.comment-author, .fn, .comment-meta');
      
      if (await commentContent.count() > 0) {
        await expect(commentContent.first()).toBeVisible();
        console.log('‚úÖ Contenido del comentario visible');
      }
      
      if (await commentAuthor.count() > 0) {
        await expect(commentAuthor.first()).toBeVisible();
        console.log('‚úÖ Autor del comentario visible');
      }
    } else {
      console.log('‚ÑπÔ∏è No se encontraron comentarios existentes en esta p√°gina');
    }
  });

  test('deber√≠a tener estructura HTML correcta para comentarios', async ({ page }) => {
    // Verificar que existe la estructura para mostrar comentarios
    const commentStructures = [
      '.comments-area',
      '#comments', 
      '.comment-list',
      'ol.commentlist',
      '.wp-block-comments'
    ];
    
    let foundStructure = false;
    
    for (const selector of commentStructures) {
      const element = page.locator(selector);
      if (await element.count() > 0) {
        foundStructure = true;
        console.log(`‚úÖ Estructura de comentarios encontrada: ${selector}`);
        break;
      }
    }
    
    // Si no hay comentarios, al menos deber√≠a existir el contenedor
    if (!foundStructure) {
      // Buscar indicadores de que el sistema est√° preparado para comentarios
      const commentRelated = page.locator('[class*="comment"], [id*="comment"], [data-comment]');
      const hasCommentRelated = await commentRelated.count() > 0;
      
      if (hasCommentRelated) {
        console.log('‚ÑπÔ∏è Sistema de comentarios detectado pero sin comentarios actuales');
      } else {
        console.log('‚ö†Ô∏è No se detect√≥ estructura de comentarios');
      }
    }
  });

  test('deber√≠a simular el flujo completo de agregar comentario', async ({ page }) => {
    // Simular el proceso completo de agregar un comentario
    const testComment = {
      content: 'Este es un comentario de prueba para verificar el flujo completo',
      author: 'Usuario Test',
      email: 'test@ejemplo.com',
      url: 'https://ejemplo.com'
    };
    
    // Contar comentarios antes (si los hay)
    const commentsBefore = await page.locator('.comment, .comment-body, li[id*="comment-"]').count();
    console.log(`üìä Comentarios antes: ${commentsBefore}`);
    
    // Llenar formulario
    await page.fill('textarea[name="comment"]', testComment.content);
    await page.fill('input[name="author"]', testComment.author);
    await page.fill('input[name="email"]', testComment.email);
    
    const urlField = page.locator('input[name="url"]');
    if (await urlField.count() > 0) {
      await page.fill('input[name="url"]', testComment.url);
    }
    
    // Simular respuesta exitosa del servidor
    await page.route('**/*wp-comments-post.php*', route => {
      console.log('üîÑ Simulando env√≠o exitoso de comentario');
      
      // Simular redirecci√≥n de vuelta a la p√°gina con el nuevo comentario
      route.fulfill({
        status: 302,
        headers: {
          'Location': route.request().url().split('wp-comments-post.php')[0] + '?p=109#comment-new'
        }
      });
    });
    
    // Enviar formulario
    const submitButton = page.locator('input[type="submit"], button[type="submit"]');
    await submitButton.click();
    
    // Esperar a que se procese
    await page.waitForTimeout(1000);
    
    console.log('‚úÖ Flujo de env√≠o de comentario simulado correctamente');
  });

  test('deber√≠a manejar errores de env√≠o de comentarios', async ({ page }) => {
    // Verificar que el formulario est√° visible antes de empezar
    const commentForm = page.locator('#respond, #commentform, .comment-form, .comment-form-wrapper');
    await expect(commentForm.first()).toBeVisible({ timeout: 15000 });
    
    // Llenar formulario con datos v√°lidos
    await page.fill('textarea[name="comment"]', 'Comentario de prueba');
    await page.fill('input[name="author"]', 'Test User');
    await page.fill('input[name="email"]', 'test@test.com');
    
    // Simular error del servidor
    await page.route('**/*wp-comments-post.php*', route => {
      console.log('üö´ Simulando error del servidor');
      route.fulfill({
        status: 500,
        body: 'Error interno del servidor'
      });
    });
    
    const submitButton = page.locator('input[type="submit"], button[type="submit"]');
    await submitButton.click();
    
    // Verificar que el usuario permanece en la p√°gina o ve un mensaje de error
    await page.waitForTimeout(2000);
    
    // El formulario deber√≠a seguir visible para reintentar
    // En caso de error, el usuario deber√≠a permanecer en la misma p√°gina
    const currentUrl = page.url();
    expect(currentUrl).toContain('p=109');
    
    console.log('‚úÖ Manejo de errores verificado - usuario permanece en la p√°gina');
  });

  test('deber√≠a verificar accesibilidad del sistema de comentarios', async ({ page }) => {
    // Verificar etiquetas y asociaciones
    const commentTextarea = page.locator('textarea[name="comment"]');
    const commentLabel = page.locator('label[for="comment"]');
    
    if (await commentLabel.count() > 0) {
      await expect(commentLabel).toBeVisible();
      console.log('‚úÖ Label para textarea de comentario presente');
    }
    
    // Verificar campos requeridos tienen indicaci√≥n
    const requiredFields = page.locator('input[required], textarea[required]');
    const requiredCount = await requiredFields.count();
    
    if (requiredCount > 0) {
      console.log(`‚úÖ ${requiredCount} campos marcados como requeridos`);
      
      // Verificar que hay indicaci√≥n visual de campos requeridos
      const hasRequiredIndicator = await page.evaluate(() => {
        const required = document.querySelectorAll('[required]');
        return Array.from(required).some(field => {
          const label = document.querySelector(`label[for="${field.id}"]`);
          return label && (label.textContent.includes('*') || label.textContent.includes('requerido'));
        });
      });
      
      if (hasRequiredIndicator) {
        console.log('‚úÖ Indicadores visuales de campos requeridos presentes');
      }
    }
    
    // Verificar roles ARIA si est√°n presentes
    const ariaElements = page.locator('[role], [aria-label], [aria-describedby]');
    const ariaCount = await ariaElements.count();
    
    if (ariaCount > 0) {
      console.log(`‚úÖ ${ariaCount} elementos con atributos ARIA encontrados`);
    }
  });
});